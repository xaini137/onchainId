{
	"id": "c8de7b7f2a113bbb16d6e7ddaaad382d",
	"_format": "hh-sol-build-info-1",
	"solcVersion": "0.8.20",
	"solcLongVersion": "0.8.20+commit.a1b79de6",
	"input": {
		"language": "Solidity",
		"sources": {
			"ERC1404/updated1404.sol": {
				"content": "// //SPDX-License-Identifier: UNLICENSED\r\n// pragma solidity 0.8.20;\r\n\r\n \r\n// interface IERC1404 {\r\n//     function detectTransferRestriction(\r\n//         address from,\r\n//         address to,\r\n//         uint256 value\r\n//     ) external view returns (uint8);\r\n\r\n//     function detectTransferFromRestriction(\r\n//         address sender,\r\n//         address from,\r\n//         address to,\r\n//         uint256 value\r\n//     ) external view returns (uint8);\r\n\r\n//     function messageForTransferRestriction(\r\n//         uint8 restrictionCode\r\n//     ) external view returns (string memory);\r\n// }\r\n\r\n// interface IERC1404getSuccessCode {\r\n//     function getSuccessCode() external view returns (uint256);\r\n// }\r\n\r\n// abstract contract IERC1404Success is IERC1404getSuccessCode, IERC1404 {}\r\n\r\n// interface IERC1404Validators {\r\n//     function balanceOf(address account) external view returns (uint256);\r\n\r\n//     function paused() external view returns (bool);\r\n\r\n//     function checkWhitelists(\r\n//         address from,\r\n//         address to\r\n//     ) external view returns (bool);\r\n\r\n//     function checkTimelock(\r\n//         address _address,\r\n//         uint256 amount,\r\n//         uint256 balance\r\n//     ) external view returns (bool);\r\n\r\n//     function isRegistered(address _user) external view returns (bool);\r\n// }\r\n\r\n// contract UserRegistration is AccessControl {\r\n//     bytes32 public constant USER_REGISTRAR_ROLE = keccak256(\"USER_REGISTRAR_ROLE\");\r\n//     string constant NON_US = \"NonUS\";\r\n//     string constant ACCREDITED = \"Accredited\";\r\n//     string constant INSTITUTIONAL = \"Institutional\";\r\n//     string constant CONTRACT = \"Contract\";\r\n\r\n//     mapping(address => string) private userTypes;\r\n\r\n//     event UserRegistered(address indexed user, string userType);\r\n\r\n//     modifier onlyRegistered(address user) {\r\n//         require(bytes(userTypes[user]).length != 0, \"User not registered\");\r\n//         _;\r\n//     }\r\n\r\n//     function register(\r\n//         address _user,\r\n//         string calldata _userType\r\n//     ) external onlyRole(USER_REGISTRAR_ROLE) {\r\n//         require(isValidUserType(_userType), \"Invalid user type\");\r\n//         userTypes[_user] = _userType;\r\n//         emit UserRegistered(_user, _userType);\r\n//     }\r\n\r\n//     function getUserType(address _user) external view returns (string memory) {\r\n//         return userTypes[_user];\r\n//     }\r\n\r\n//     function isRegistered(address _user) external view returns (bool) {\r\n//         return bytes(userTypes[_user]).length != 0;\r\n//     }\r\n\r\n//     function isValidUserType(\r\n//         string memory _userType\r\n//     ) internal pure returns (bool) {\r\n//         return (keccak256(abi.encodePacked(_userType)) ==\r\n//             keccak256(abi.encodePacked(NON_US)) ||\r\n//             keccak256(abi.encodePacked(_userType)) ==\r\n//             keccak256(abi.encodePacked(ACCREDITED)) ||\r\n//             keccak256(abi.encodePacked(_userType)) ==\r\n//             keccak256(abi.encodePacked(CONTRACT)) ||\r\n//             keccak256(abi.encodePacked(_userType)) ==\r\n//             keccak256(abi.encodePacked(INSTITUTIONAL)));\r\n//     }\r\n// }\r\n\r\n// contract Whitelistable is AccessControl {\r\n//     bytes32 public constant WHITELISTER_ROLE = keccak256(\"WHITELISTER_ROLE\");\r\n//     event WhitelistUpdate(address _address, bool status, string data);\r\n\r\n//     struct whiteListItem {\r\n//         bool status;\r\n//         string data;\r\n//     }\r\n\r\n//     mapping(address => whiteListItem) public whitelist;\r\n\r\n//     function setWhitelist(\r\n//         address to,\r\n//         bool status,\r\n//         string memory data\r\n//     ) public onlyRole(WHITELISTER_ROLE) returns (bool) {\r\n//         whitelist[to] = whiteListItem(status, data);\r\n//         emit WhitelistUpdate(to, status, data);\r\n//         return true;\r\n//     }\r\n\r\n//     function getWhitelistStatus(address _address) public view returns (bool) {\r\n//         return whitelist[_address].status;\r\n//     }\r\n\r\n//     function getWhitelistData(\r\n//         address _address\r\n//     ) public view returns (string memory) {\r\n//         return whitelist[_address].data;\r\n//     }\r\n\r\n//     function checkWhitelists(\r\n//         address from,\r\n//         address to\r\n//     ) external view returns (bool) {\r\n//         return whitelist[from].status;\r\n//     }\r\n// }\r\n\r\n// contract Timelockable is AccessControl {\r\n//     bytes32 public constant TIMELOCKER_ROLE = keccak256(\"TIMELOCKER_ROLE\");\r\n//     struct LockupItem {\r\n//         uint256 amount;\r\n//         uint256 releaseTime;\r\n//     }\r\n\r\n//     mapping(address => LockupItem[]) public lockups;\r\n\r\n//     event AccountLock(\r\n//         address indexed _address,\r\n//         uint256 amount,\r\n//         uint256 releaseTime\r\n//     );\r\n//     event AccountRelease(address indexed _address, uint256 amount);\r\n\r\n//     function _lock(\r\n//         address _address,\r\n//         uint256 amount,\r\n//         uint256 releaseTime\r\n//     ) internal {\r\n//         require(releaseTime > block.timestamp, \"Release time in the future\");\r\n//         require(_address != address(0), \"Address must be valid\");\r\n//         lockups[_address].push(LockupItem(amount, releaseTime));\r\n//         emit AccountLock(_address, amount, releaseTime);\r\n//     }\r\n\r\n//     function lock(\r\n//         address _address,\r\n//         uint256 amount,\r\n//         uint256 releaseTime\r\n//     ) external returns (bool) {\r\n//         _lock(_address, amount, releaseTime);\r\n//         return true;\r\n//     }\r\n\r\n//     function release(\r\n//         address _address,\r\n//         uint256 amountToRelease\r\n//     ) public onlyRole(TIMELOCKER_ROLE) returns (bool) {\r\n//         require(_address != address(0), \"Invalid address\");\r\n\r\n//         uint256 totalReleased = 0;\r\n//         LockupItem[] storage userLockups = lockups[_address];\r\n\r\n//         for (uint256 i = 0; i < userLockups.length; i++) {\r\n//             if (\r\n//                 userLockups[i].releaseTime <= block.timestamp &&\r\n//                 totalReleased < amountToRelease\r\n//             ) {\r\n//                 uint256 remainingAmount = amountToRelease - totalReleased;\r\n//                 if (userLockups[i].amount <= remainingAmount) {\r\n//                     totalReleased = totalReleased + userLockups[i].amount;\r\n//                     userLockups[i].amount = 0;\r\n//                 } else {\r\n//                     userLockups[i].amount =\r\n//                         userLockups[i].amount -\r\n//                         remainingAmount;\r\n//                     totalReleased = totalReleased + remainingAmount;\r\n//                 }\r\n//             }\r\n//         }\r\n\r\n//         emit AccountRelease(_address, totalReleased);\r\n//         return true;\r\n//     }\r\n\r\n//     function checkTimelock(\r\n//         address _address,\r\n//         uint256 amount,\r\n//         uint256 balance\r\n//     ) external view returns (bool) {\r\n//         uint256 lockedAmount = getLockedAmount(_address);\r\n//         if (balance < amount) {\r\n//             return false;\r\n//         }\r\n//         uint256 nonLockedAmount = balance + lockedAmount;\r\n//         return amount <= nonLockedAmount;\r\n//     }\r\n\r\n//     function getLockedAmount(address _address) public view returns (uint256) {\r\n//         uint256 totalLocked = 0;\r\n//         LockupItem[] storage userLockups = lockups[_address];\r\n\r\n//         for (uint256 i = 0; i < userLockups.length; i++) {\r\n//             if (block.timestamp < userLockups[i].releaseTime) {\r\n//                 totalLocked = totalLocked + userLockups[i].amount;\r\n//             }\r\n//         }\r\n\r\n//         return totalLocked;\r\n//     }\r\n// }\r\n\r\n// contract Proton is\r\n//     IERC1404,\r\n//     ERC20,\r\n//     AccessControl,\r\n//     Whitelistable,\r\n//     Timelockable,\r\n//     Pausable,\r\n//     UserRegistration,\r\n//     ERC20Pausable\r\n// {\r\n//     string constant TOKEN_NAME = \"PROTON\";\r\n//     string constant TOKEN_SYMBOL = \"PRTN\";\r\n//     uint8 constant TOKEN_DECIMALS = 18;\r\n//     bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\r\n//     bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\r\n//     IERC1404Success private transferRestrictions;\r\n//     event RestrictionsUpdated(\r\n//         address newRestrictionsAddress,\r\n//         address updatedBy\r\n//     );\r\n//     event Revoke(address indexed revoker, address indexed from, uint256 amount);\r\n\r\n//     constructor(\r\n//         address admin,\r\n//         address pauser,\r\n//         address minter,\r\n//         address registrar,\r\n//          address whitelister\r\n//     ) ERC20(TOKEN_NAME, TOKEN_SYMBOL) {\r\n//         _grantRole(USER_REGISTRAR_ROLE, registrar);\r\n//         _grantRole(DEFAULT_ADMIN_ROLE, admin);\r\n//         _grantRole(PAUSER_ROLE, pauser);\r\n//         _grantRole(MINTER_ROLE, minter);\r\n//          _grantRole(WHITELISTER_ROLE, whitelister);\r\n//     }\r\n\r\n//     function updateTransferRestrictions(\r\n//         address _newRestrictionsAddress\r\n//     ) public onlyRole(DEFAULT_ADMIN_ROLE) returns (bool) {\r\n//         transferRestrictions = IERC1404Success(_newRestrictionsAddress);\r\n//         emit RestrictionsUpdated(address(transferRestrictions), msg.sender);\r\n//         return true;\r\n//     }\r\n\r\n//     function revoke(\r\n//         address _from,\r\n//         uint256 _amount\r\n//     ) public onlyRole(DEFAULT_ADMIN_ROLE) returns (bool) {\r\n//         ERC20._transfer(_from, msg.sender, _amount);\r\n//         emit Revoke(msg.sender, _from, _amount);\r\n//         return true;\r\n//     }\r\n\r\n//     function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {\r\n//         _mint(to, amount);\r\n//     }\r\n\r\n//     function _update(\r\n//         address from,\r\n//         address to,\r\n//         uint256 value\r\n//     ) internal override(ERC20, ERC20Pausable) {\r\n//         super._update(from, to, value);\r\n//     }\r\n\r\n//     function burn(\r\n//         address _from,\r\n//         uint256 _amount\r\n//     ) public onlyRole(DEFAULT_ADMIN_ROLE) returns (bool) {\r\n//         _burn(_from, _amount);\r\n//         return true;\r\n//     }\r\n\r\n//     function pause() public onlyRole(PAUSER_ROLE) {\r\n//         _pause();\r\n//     }\r\n\r\n//     function unpause() public onlyRole(PAUSER_ROLE) {\r\n//         _unpause();\r\n//     }\r\n\r\n//     function detectTransferRestriction(\r\n//         address from,\r\n//         address to,\r\n//         uint256 amount\r\n//     ) public view returns (uint8) {\r\n//         require(\r\n//             address(transferRestrictions) != address(0),\r\n//             \"TransferRestrictions contract must be set\"\r\n//         );\r\n//         return transferRestrictions.detectTransferRestriction(from, to, amount);\r\n//     }\r\n\r\n//     function detectTransferFromRestriction(\r\n//         address sender,\r\n//         address from,\r\n//         address to,\r\n//         uint256 amount\r\n//     ) public view returns (uint8) {\r\n//         require(\r\n//             address(transferRestrictions) != address(0),\r\n//             \"TransferRestrictions contract must be set\"\r\n//         );\r\n//         return\r\n//             transferRestrictions.detectTransferFromRestriction(\r\n//                 sender,\r\n//                 from,\r\n//                 to,\r\n//                 amount\r\n//             );\r\n//     }\r\n\r\n//     function messageForTransferRestriction(\r\n//         uint8 restrictionCode\r\n//         ) external view returns (string memory) {\r\n//         return\r\n//             transferRestrictions.messageForTransferRestriction(restrictionCode);\r\n//     }\r\n\r\n//     modifier notRestricted(\r\n//         address from,\r\n//         address to,\r\n//         uint256 value\r\n//     ) {\r\n//         uint8 restrictionCode = transferRestrictions.detectTransferRestriction(\r\n//             from,\r\n//             to,\r\n//             value\r\n//         );\r\n//         require(\r\n//             restrictionCode == transferRestrictions.getSuccessCode(),\r\n//             transferRestrictions.messageForTransferRestriction(restrictionCode)\r\n//         );\r\n//         _;\r\n//     }\r\n\r\n//     modifier notRestrictedTransferFrom(\r\n//         address sender,\r\n//         address from,\r\n//         address to,\r\n//         uint256 value\r\n//     ) {\r\n//         uint8 transferFromRestrictionCode = transferRestrictions\r\n//             .detectTransferFromRestriction(sender, from, to, value);\r\n//         require(\r\n//             transferFromRestrictionCode ==\r\n//                 transferRestrictions.getSuccessCode(),\r\n//             transferRestrictions.messageForTransferRestriction(\r\n//                 transferFromRestrictionCode\r\n//             )\r\n//         );\r\n//         _;\r\n//     }\r\n\r\n//     function transfer(\r\n//         address to,\r\n//         uint256 value\r\n//     )\r\n//         public\r\n//         override\r\n//         notRestricted(msg.sender, to, value)\r\n//         returns (bool success)\r\n//     {\r\n//         success = ERC20.transfer(to, value);\r\n//     }\r\n\r\n//     function transferFrom(\r\n//         address from,\r\n//         address to,\r\n//         uint256 value\r\n//     )\r\n//         public\r\n//         override\r\n//         notRestrictedTransferFrom(msg.sender, from, to, value)\r\n//         returns (bool success)\r\n//     {\r\n//         success = ERC20.transferFrom(from, to, value);\r\n//     }\r\n// }"
			}
		},
		"settings": {
			"optimizer": {
				"enabled": false,
				"runs": 200
			},
			"outputSelection": {
				"*": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"metadata",
						"devdoc",
						"userdoc",
						"storageLayout",
						"evm.legacyAssembly",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"evm.gasEstimates",
						"evm.assembly"
					]
				}
			},
			"remappings": []
		}
	},
	"output": {
		"errors": [
			{
				"component": "general",
				"errorCode": "3420",
				"formattedMessage": "Warning: Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.8.20;\"\n--> ERC1404/updated1404.sol\n\n",
				"message": "Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.8.20;\"",
				"severity": "warning",
				"sourceLocation": {
					"end": -1,
					"file": "ERC1404/updated1404.sol",
					"start": -1
				},
				"type": "Warning"
			}
		],
		"sources": {
			"ERC1404/updated1404.sol": {
				"ast": {
					"absolutePath": "ERC1404/updated1404.sol",
					"exportedSymbols": {},
					"id": 1,
					"license": "UNLICENSED",
					"nodeType": "SourceUnit",
					"nodes": [],
					"src": "13151:0:0"
				},
				"id": 0
			}
		}
	}
}